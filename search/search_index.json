{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Start reading blogs here</p>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/","title":"Getting Started With Confluent Platform","text":"<p>Confluent Platform is a full-scale streaming platform that enables you to easily access, store, and manage data as continuous, real-time streams.</p> <p>Check out the official documentation of confluent here.</p>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#download-confluent-platform-in-your-local","title":"Download Confluent Platform in your local","text":"<p>Download confluent platform from confluent's official website here.</p>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#go-to-the-directory-where-confluent-platform-is-downloaded","title":"Go to the directory where Confluent Platform is downloaded","text":"<pre><code>cd directory/to/confluent/platform\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#help-command","title":"Help command","text":"<pre><code>bin/confluent local --help\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#output","title":"Output","text":"<pre><code>Use the \"confluent local\" commands to try out Confluent Platform by running a single-node instance locally on your machine. Keep in mind, these commands require Java to run.\n\nUsage:\n  confluent local [command]\n\nAvailable Commands:\n  current     Get the path of the current Confluent run.\n  destroy     Delete the data and logs for the current Confluent run.\n  services    Manage Confluent Platform services.\n  version     Print the Confluent Platform version.\n\nGlobal Flags:\n  -h, --help            Show help for this command.\n  -v, --verbose count   Increase verbosity (-v for warn, -vv for info, -vvv for debug, -vvvv for trace).\n\nUse \"confluent local [command] --help\" for more information about a command.\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#start-services","title":"Start Services","text":"<p>To know more about <code>Services</code>, use the help command:</p> <pre><code>bin/confluent local services --help\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#start-confluent-services-in-local","title":"Start confluent services in local","text":"<pre><code>bin/confluent local services start\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#output_1","title":"Output","text":"<pre><code>Using CONFLUENT_CURRENT: /var/folders/n1/zs8c9zw95ng2qy812fwv5rjh0000gn/T/confluent.646371\nStarting ZooKeeper\nZooKeeper is [UP]\nStarting Kafka\nKafka is [UP]\nStarting Schema Registry\nSchema Registry is [UP]\nStarting Kafka REST\nKafka REST is [UP]\nStarting Connect\nConnect is [UP]\nStarting ksqlDB Server\nksqlDB Server is [UP]\nStarting Control Center\nControl Center is [UP]\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#verify-that-kafka-is-running-in-local","title":"Verify that Kafka is running in local","text":"<p>This can be verified by either using cuRL or telnet:</p> <pre><code>telnet localhost 9092\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#view-the-control-center-ui","title":"View the Control Center UI","text":"<p>Control Center UI can be viewed at http://localhost:9021.</p>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#list-kafka-topics-in-the-cluster","title":"List kafka topics in the cluster","text":"<pre><code>bin/kafka-topics \\\n--list \\\n--bootstrap-server localhost:9092\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#create-a-kafka-topic","title":"Create a kafka topic","text":"<pre><code>bin/kafka-topics \\\n--create \\\n--bootstrap-server localhost:9092 \\\n--topic local_test_topic\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#verify-that-the-kafka-topic-is-created","title":"Verify that the kafka topic is created","text":"<pre><code>bin/kafka-topics \\\n--list \\\n--bootstrap-server localhost:9092 \\\n| grep 'local_test_topic'\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#output_2","title":"Output","text":"<pre><code>local_test_topic\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#describe-the-kafka-topic","title":"Describe the kafka topic","text":"<pre><code>bin/kafka-topics \\\n--describe \\\n--bootstrap-server localhost:9092 \\\n--topic local_test_topic\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#output_3","title":"Output","text":"<pre><code>Topic: local_test_topic TopicId: c1wfq1qDSXGt6gfVU3qgzQ PartitionCount: 1   ReplicationFactor: 1    Configs: segment.bytes=1073741824\nTopic: local_test_topic Partition: 0    Leader: 0   Replicas: 0 Isr: 0  Offline:\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#produce-to-the-kafka-topic","title":"Produce to the kafka topic","text":"<pre><code>bin/kafka-console-producer \\\n--bootstrap-server localhost:9092 \\\n--topic local_test_topic \\\n--property parse.key=true \\\n--property key.separator=:\n</code></pre> <p>The key and value should be separated by <code>:</code> while writing messages in the console.</p>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#example","title":"Example:","text":"<pre><code>key1:message1\nkey2:message2\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#consume-from-the-kafka-topic","title":"Consume from the kafka topic","text":"<p>Open a new tab in the terminal and consume messages from the kafka topic.</p> <pre><code>bin/kafka-console-consumer \\\n--bootstrap-server localhost:9092 \\\n--topic local_test_topic \\\n--property print.key=true \\\n--from-beginning\n</code></pre>"},{"location":"blog/2024/03/16/getting-started-with-confluent-platform/#output_4","title":"Output","text":"<pre><code>key1    message1\nkey2    message2\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/","title":"Simple Kafka Producer and Consumer using Python","text":"<p>To create Kafka producer and Consumer using Python, you'll need to use the kafka-python library, which is a popular choice for interacting with Apache Kafka in Python. Before you begin, ensure that you have Kafka installed and running in local.</p>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#start-kafka-in-local","title":"Start Kafka in local","text":"<p>For details, please checkout this blog</p>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#go-to-the-directory-where-confluent-platform-is-downloaded","title":"Go to the directory where Confluent Platform is downloaded","text":"<pre><code>cd directory/to/confluent/platform\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#start-confluent-services-in-local","title":"Start confluent services in local","text":"<pre><code>bin/confluent local services start\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#create-a-kafka-topic","title":"Create a kafka topic","text":"<pre><code>bin/kafka-topics \\\n--create \\\n--bootstrap-server localhost:9092 \\\n--topic local_test_topic\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#installations","title":"Installations","text":"<p>Note: Make sure you already have <code>python3</code> and <code>pip</code> installed.</p>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#install-kafka-python","title":"Install <code>kafka-python</code>","text":"<pre><code>pip3 install kafka-python\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#install-uuid","title":"Install <code>uuid</code>","text":"<pre><code>pip3 install uuid\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#simple-kafka-producer-using-python","title":"Simple Kafka Producer using Python","text":""},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#producerpy-file","title":"<code>producer.py</code> file","text":"<pre><code>import uuid\n\nfrom kafka import KafkaProducer\n\nbootstrap_servers = 'localhost:9092'\ntopic_name = 'local_test_topic'\n\n\ndef produce():\n  producer = KafkaProducer(bootstrap_servers=bootstrap_servers, key_serializer=str.encode, value_serializer=str.encode)\n\n  try:\n    while True:\n      key = str(uuid.uuid4())\n      value = str(uuid.uuid4())\n      producer.send(topic=topic_name, key=key, value=value)\n      producer.flush()\n      print(\"Message sent key: \" + key + \" and value \" + value)\n  finally:\n    producer.flush()\n\n\nif __name__ == \"__main__\":\n  produce()\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#run-producer-code","title":"Run producer code","text":"<pre><code>python3 producer.py\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#simple-kafka-consumer-using-python","title":"Simple Kafka Consumer using Python","text":""},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#consumerpy-file","title":"<code>consumer.py</code> file","text":"<pre><code>from kafka import KafkaConsumer\n\nbootstrap_servers = 'localhost:9092'\ntopic_name = 'local_test_topic'\n\n\ndef consume():\n  consumer = KafkaConsumer(topic_name,  # Topic name to consume messages from\n                           group_id='my-group',  # Consumer group ID\n                           bootstrap_servers=bootstrap_servers,\n                           auto_offset_reset='earliest',  # Reset offset to beginning\n                           enable_auto_commit=True)  # Enable auto commit\n\n  for message in consumer:\n    key = message.key.decode('utf-8') if message.key else None\n    value = message.value.decode('utf-8') if message.value else None\n\n    print(f\"Received message: Key={key}, Value={value}, Partition={message.partition}, Offset={message.offset}\")\n\n  consumer.close()\n\n\nif __name__ == \"__main__\":\n  consume()\n</code></pre>"},{"location":"blog/2024/03/17/simple-kafka-producer-and-consumer-using-python/#run-consumer-code","title":"Run consumer code","text":"<pre><code>python3 consumer.py\n</code></pre>"},{"location":"leetcode-easy/add-number-strings/","title":"Add Number Strings","text":""},{"location":"leetcode-easy/add-number-strings/#link-httpsleetcodecomproblemsadd-stringsdescription","title":"Link - https://leetcode.com/problems/add-strings/description/","text":"<pre><code>class Solution {\npublic String addStrings(String num1, String num2) {\nStringBuilder result = new StringBuilder();\nint carry = 0;\nint i = num1.length() - 1, j = num2.length() - 1;\n\nwhile (i &gt;= 0 || j &gt;= 0 || carry &gt; 0) {\nint digit1 = (i &gt;= 0) ? num1.charAt(i--) - '0' : 0;\nint digit2 = (j &gt;= 0) ? num2.charAt(j--) - '0' : 0;\nint sum = digit1 + digit2 + carry;\nresult.append(sum % 10);\ncarry = sum / 10;\n}\n\nreturn result.reverse().toString();\n}\n}\n</code></pre>"},{"location":"leetcode-easy/add-number-strings/#explanation","title":"Explanation","text":"<ul> <li> <p>StringBuilder Initialization: The method initializes a <code>StringBuilder</code> named <code>result</code> to store the result of addition.</p> </li> <li> <p>Carry Initialization: It initializes an integer variable <code>carry</code> to store the carry generated during addition.</p> </li> <li> <p>Pointer Initialization: It initializes two pointers <code>i</code> and <code>j</code> to the last digits of <code>num1</code> and <code>num2</code>, respectively.</p> </li> <li> <p>Addition Loop: The method iterates through both numbers from their last digits to their first digits, or until there's no carry left. It handles addition of corresponding   digits along with the carry.</p> </li> <li> <p>Digit Retrieval: Inside the loop, it retrieves the current digits from <code>num1</code> and <code>num2</code>, or 0 if either of the numbers is exhausted.</p> </li> <li> <p>Sum Calculation: It calculates the sum of current digits along with the carry and appends the last digit of the sum to the <code>result</code> StringBuilder.</p> </li> <li> <p>Carry Update: It updates the carry for the next iteration based on the sum.</p> </li> <li> <p>Final Result: After the loop, it reverses the <code>result</code> StringBuilder to obtain the final result and returns it as a string.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"leetcode-easy/array-partition/","title":"Array Partition","text":""},{"location":"leetcode-easy/array-partition/#link-httpsleetcodecomproblemsarray-partitiondescription","title":"Link - https://leetcode.com/problems/array-partition/description/","text":""},{"location":"leetcode-easy/array-partition/#given-an-integer-array-nums-of-2n-integers-group-these-integers-into-n-pairs-a1-b1-a2-b2-an-bn-such-that-the-sum-of-minai-bi-for-all-i-is-maximized-return-the-maximized-sum","title":"Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.","text":"<pre><code>class Solution {\npublic int arrayPairSum(int[] nums) {\nArrays.sort(nums);\n\nint sum = 0;\nfor (int i = 0; i &lt; nums.length; i += 2) {\nsum += Math.min(nums[i], nums[i + 1]);\n}\n\nreturn sum;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/array-partition/#explanation","title":"Explanation","text":"<ul> <li>Sorting: The <code>arrayPairSum</code> method starts by sorting the given array in ascending order. This is crucial for maximizing the sum of minimum pairs since pairs are formed by adjacent elements after sorting.</li> <li>Iterating and Summing Pairs: After sorting, the algorithm iterates through the sorted array by pairs (i.e., increments <code>i</code> by 2 in each iteration). For each pair, it adds the minimum of the two elements to the sum.</li> <li>Maximizing Sum: By sorting the array and summing the minimum of each pair, the algorithm ensures that it maximizes the sum of min pairs. Sorting allows pairing the smallest numbers together, ensuring that the minimum of each pair contributes to the sum.</li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(nlog(n))</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"leetcode-easy/assign-cookies/","title":"Assign Cookies","text":"<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p> <p>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>"},{"location":"leetcode-easy/assign-cookies/#link-httpsleetcodecomproblemsassign-cookiesdescription","title":"Link - https://leetcode.com/problems/assign-cookies/description/","text":"<pre><code>class Solution {\npublic int findContentChildren(int[] g, int[] s) {\n// Sort the arrays of greed factors and cookie sizes\nArrays.sort(g);\nArrays.sort(s);\n\n// Initialize variables for counting content children and tracking array indices\nint count = 0;\nint i = 0; // Index for greed factors array\nint j = 0; // Index for cookie sizes array\n\n// Iterate through both arrays simultaneously\nwhile (i &lt; g.length &amp;&amp; j &lt; s.length) {\n// If the current cookie size is sufficient for the current child's greed factor,\n// assign the cookie to the child and increment both child and cookie indices\nif (s[j] &gt;= g[i]) {\ncount++;\ni++;\nj++;\n} else {\n// If the current cookie size is not sufficient for the current child's greed factor,\n// move to the next cookie size while keeping the current child\nj++;\n}\n}\n\n// Return the count of content children\nreturn count;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/assign-cookies/#explanation","title":"Explanation","text":"<ul> <li> <p>Array Sorting: The method starts by sorting the arrays of greed factors (<code>g</code>) and cookie sizes (<code>s</code>). Sorting allows for efficient comparison of greed factors and cookie   sizes later in the algorithm.</p> </li> <li> <p>Variable Initialization: It initializes variables <code>count</code>, <code>i</code>, and <code>j</code>. <code>count</code> stores the count of content children, while <code>i</code> and <code>j</code> are indices for iterating through the   greed factors and cookie sizes arrays, respectively.</p> </li> <li> <p>Iteration through Arrays: The method iterates through both arrays simultaneously using the <code>while</code> loop. It continues iterating until either the end of the greed factors   array (<code>g</code>) or the end of the cookie sizes array (<code>s</code>) is reached.</p> </li> <li> <p>Comparison and Assignment: For each iteration, it compares the current greed factor (<code>g[i]</code>) with the current cookie size (<code>s[j]</code>). If the cookie size is sufficient for the   greed factor, it increments the <code>count</code> variable to indicate a content child and moves to the next greed factor and cookie size. If the cookie size is insufficient, it moves to   the next cookie size while keeping the current greed factor.</p> </li> <li> <p>Returning Result: After iterating through both arrays, it returns the count of content children.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(nlog(n))</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"leetcode-easy/average-of-levels-in-binary-tree/","title":"Average of levels in Binary Tree","text":""},{"location":"leetcode-easy/average-of-levels-in-binary-tree/#link-httpsleetcodecomproblemsaverage-of-levels-in-binary-tree","title":"Link - https://leetcode.com/problems/average-of-levels-in-binary-tree/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\npublic List&lt;Double&gt; averageOfLevels(TreeNode root) {\nList&lt;Double&gt; answer = new ArrayList&lt;&gt;();\nif (root == null) {\nreturn answer;\n}\n\nQueue&lt;TreeNode&gt; Q = new LinkedList&lt;&gt;();\nQ.offer(root);\n\nwhile (!Q.isEmpty()) {\nint nodesInCurrentLevel = Q.size();\nDouble sum = 0.0;\nint n = nodesInCurrentLevel;\nwhile (n-- &gt; 0) {\nTreeNode node = Q.poll();\nsum += node.val;\nif (node.left != null) {\nQ.offer(node.left);\n}\nif (node.right != null) {\nQ.offer(node.right);\n}\n}\nDouble average = sum / nodesInCurrentLevel;\nanswer.add(average);\n}\nreturn answer;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/average-of-levels-in-binary-tree/#explanation","title":"Explanation:","text":"<ul> <li> <p>Node Definition: The code begins with the definition of the binary tree node class <code>TreeNode</code>, which includes a value (<code>val</code>), and references to the left and right child   nodes (<code>left</code> and <code>right</code>).</p> </li> <li> <p>Method Explanation: The <code>averageOfLevels</code> method calculates the average value of nodes at each level of the binary tree.</p> </li> <li> <p>Base Case: It starts with a base case where it checks if the root is null. If the root is null, it returns an empty list, indicating that there are no levels to compute   averages for.</p> </li> <li> <p>Level Order Traversal: It performs level order traversal of the binary tree using a queue (<code>Q</code>). It starts by adding the root node to the queue.</p> </li> <li> <p>Processing Each Level: While the queue is not empty, it processes each level:</p> <ul> <li>It gets the number of nodes in the current level (<code>nodesInCurrentLevel</code>) and initializes a sum to store the sum of values of nodes in the current level.</li> <li>It iterates through the nodes in the current level, calculates the sum of their values, and adds their children to the queue for the next level.</li> <li>After processing all nodes in the current level, it calculates the average value of nodes in that level and adds it to the list of averages.</li> </ul> </li> <li> <p>Return Value: Finally, it returns the list of averages of levels.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/binary-tree-paths/","title":"Binary Tree Paths","text":""},{"location":"leetcode-easy/binary-tree-paths/#link-httpsleetcodecomproblemsbinary-tree-pathsdescription","title":"Link - https://leetcode.com/problems/binary-tree-paths/description/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\npublic List&lt;String&gt; binaryTreePaths(TreeNode root) {\nList&lt;String&gt; answer = new ArrayList&lt;&gt;();\nbinaryTreePaths(root, answer, \"\");\nreturn answer;\n}\n\nprivate static void binaryTreePaths(TreeNode root, List&lt;String&gt; answer, String currentString) {\nif (root == null) {\nreturn;\n}\n\nString path = currentString == \"\" ? String.valueOf(root.val) : currentString + \"-&gt;\" + String.valueOf(root.val);\n\nif (root.left == null &amp;&amp; root.right == null) {\nanswer.add(path);\nreturn;\n}\n\nbinaryTreePaths(root.left, answer, path);\nbinaryTreePaths(root.right, answer, path);\n}\n}\n</code></pre>"},{"location":"leetcode-easy/binary-tree-paths/#explanation","title":"Explanation:","text":"<ul> <li> <p>Finding All Paths: The <code>binaryTreePaths</code> method is the entry point of the algorithm. It initializes a list to store paths and calls a recursive method to find all paths in   the binary tree.</p> </li> <li> <p>Recursive Path Building: The <code>binaryTreePaths</code> method recursively builds the path string as it traverses the binary tree. It appends each node's value to the current path   string and updates it accordingly.</p> </li> <li> <p>Base Case: If the current node is null, it means the path has reached its end, so the method returns.</p> </li> <li> <p>Leaf Node Handling: If the current node is a leaf node (both left and right children are null), it means a complete path is found, so it adds the path to the answer list.</p> </li> <li> <p>Recursion: It recursively traverses the left and right subtrees, passing the updated path string to each recursive call.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n) [due to call stack]</li> </ul>"},{"location":"leetcode-easy/corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/","title":"Find a Corresponding Node of a Binary Tree in a Clone of That Tree","text":""},{"location":"leetcode-easy/corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/#link-httpsleetcodecomproblemsfind-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-treedescription","title":"Link - https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\nprivate TreeNode answer = null;\n\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n// Call helper function to find the target node in the cloned tree\ntargetCopy(original, cloned, target);\nreturn answer;\n}\n\nprivate void targetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n// Base case: If either tree is null, return\nif (cloned == null || original == null) {\nreturn;\n}\n\n// If the current node in the cloned tree matches the target node\nif (cloned.val == target.val) {\nanswer = cloned; // Update answer to the current cloned node\nreturn;\n}\n\n// Recursively search the left subtree\ntargetCopy(original.left, cloned.left, target);\n\n// Recursively search the right subtree\ntargetCopy(original.right, cloned.right, target);\n}\n}\n</code></pre>"},{"location":"leetcode-easy/corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/#explanation","title":"Explanation","text":"<ul> <li> <p>Method Signature:</p> <ul> <li>The <code>getTargetCopy</code> method initializes <code>answer</code> and calls the recursive helper function <code>targetCopy</code> to find the corresponding node in the cloned tree.</li> </ul> </li> <li> <p>Recursive Helper Function (<code>targetCopy</code>):</p> <ul> <li>This function takes three parameters: <code>original</code> (current node in the original tree), <code>cloned</code> (current node in the cloned tree), and <code>target</code> (target node in the original tree).</li> <li>Base Case:<ul> <li>If either <code>cloned</code> or <code>original</code> is <code>null</code>, return without further processing.</li> </ul> </li> <li>If the current node in the <code>cloned</code> tree matches the target node (<code>target</code>), update <code>answer</code> to this node.</li> <li>Recursively call <code>targetCopy</code> for the left and right children of both <code>original</code> and <code>cloned</code> trees to continue the search.</li> </ul> </li> <li> <p>Returning Result:</p> <ul> <li>After the recursive traversal completes, <code>answer</code> holds the reference to the corresponding node in the cloned tree that matches the target node.</li> <li>Return <code>answer</code> as the result of the function.</li> </ul> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/#level-order-traversal-solution","title":"Level order Traversal Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\nQueue&lt;TreeNode&gt; Q = new LinkedList&lt;&gt;();\nQ.offer(cloned);\n\nwhile (!Q.isEmpty()) {\nTreeNode node = Q.poll();\nif (node.val == target.val) {\nreturn node;\n}\nif (node.left != null) {\nQ.offer(node.left);\n}\nif (node.right != null) {\nQ.offer(node.right);\n}\n}\n\nreturn null;\n}\n}\n</code></pre> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/evaluate-boolean-binary-tree/","title":"Evaluate Boolean Binary Tree","text":""},{"location":"leetcode-easy/evaluate-boolean-binary-tree/#link-httpsleetcodecomproblemsevaluate-boolean-binary-tree","title":"Link - https://leetcode.com/problems/evaluate-boolean-binary-tree/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\npublic boolean evaluateTree(TreeNode root) {\nif (root == null) {\nreturn true;\n}\nif (root.left == null &amp;&amp; root.right == null) {\nreturn root.val == 0 ? false : true;\n}\nif (root.val == 2) {\nreturn evaluateTree(root.left) || evaluateTree(root.right);\n}\nreturn evaluateTree(root.left) &amp;&amp; evaluateTree(root.right);\n}\n}\n</code></pre>"},{"location":"leetcode-easy/evaluate-boolean-binary-tree/#explanation","title":"Explanation:","text":"<ul> <li>Base Case (<code>root == null</code>):<ul> <li>If the <code>root</code> node is <code>null</code>, indicating an empty tree, the method returns <code>true</code>. An empty tree is considered valid.</li> </ul> </li> <li>Leaf Node Evaluation (<code>root.left == null &amp;&amp; root.right == null</code>):<ul> <li>If the <code>root</code> node has no children (<code>left</code> and <code>right</code> are both <code>null</code>), it is considered a leaf node.</li> </ul> </li> <li>The leaf node's value (<code>root.val</code>) is evaluated:<ul> <li>If <code>root.val</code> is <code>0</code>, return <code>false</code> (representing <code>False</code>).</li> <li>If <code>root.val</code> is <code>1</code>, return <code>true</code> (representing <code>True</code>).</li> </ul> </li> <li>Non-leaf Node Evaluation (<code>root.val == 2</code> or <code>root.val == 3</code>):<ul> <li>For non-leaf nodes (<code>root.val</code> is <code>2</code> for OR, <code>3</code> for AND), recursively evaluate the left and right subtrees (<code>root.left</code> and <code>root.right</code>):<ul> <li>If <code>root.val</code> is <code>2</code> (OR), return the logical OR (<code>||</code>) of the evaluations of the left and right subtrees.</li> <li>If <code>root.val</code> is <code>3</code> (AND), return the logical AND (<code>&amp;&amp;</code>) of the evaluations of the left and right subtrees.</li> </ul> </li> </ul> </li> </ul>"},{"location":"leetcode-easy/evaluate-boolean-binary-tree/#key-points","title":"Key Points:","text":"<ul> <li> <p>Base Case Handling:</p> <ul> <li>The method handles the base case where the <code>root</code> node is <code>null</code>, ensuring that an empty tree is considered valid.</li> </ul> </li> <li> <p>Leaf Node Handling:</p> <ul> <li>Leaf nodes are identified based on the absence of children (<code>left</code> and <code>right</code> are both <code>null</code>).</li> <li>The boolean value (<code>true</code> or <code>false</code>) of a leaf node is determined by its <code>val</code> property (<code>0</code> for <code>false</code>, <code>1</code> for <code>true</code>).</li> </ul> </li> <li> <p>Non-leaf Node Handling:</p> <ul> <li>Non-leaf nodes (<code>2</code> for OR, <code>3</code> for AND) recursively evaluate their children and apply the corresponding boolean operation (<code>||</code> or <code>&amp;&amp;</code>) to determine their boolean value.</li> </ul> </li> </ul>"},{"location":"leetcode-easy/find-all-numbers-disappeared-in-an-array/","title":"Find All Numbers Disappeared in an Array","text":""},{"location":"leetcode-easy/find-all-numbers-disappeared-in-an-array/#link-httpsleetcodecomproblemsfind-all-numbers-disappeared-in-an-arraydescription","title":"Link - https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/","text":""},{"location":"leetcode-easy/find-all-numbers-disappeared-in-an-array/#method-1-using-visited-array","title":"Method 1 (Using visited array)","text":"<p>This solution first creates a boolean array to track visited numbers, then loops through the array to find the missing numbers, and returns a list containing those missing numbers.</p> <pre><code>class Solution {\npublic List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {\nboolean[] visited = visitedArray(nums);\n\nList&lt;Integer&gt; answer = new ArrayList&lt;&gt;();\nfor (int i = 1; i &lt; visited.length; i++) {\nif (visited[i] == false) {\nanswer.add(i);\n}\n}\n\nreturn answer;\n}\n\nprivate static boolean[] visitedArray(int[] nums) {\nboolean[] visited = new boolean[nums.length + 1];\nfor (int i = 0; i &lt; nums.length; i++) {\nvisited[nums[i]] = true;\n}\nreturn visited;\n}\n}\n</code></pre> <p>This code:</p> <ul> <li>Creates a boolean array to mark which numbers are visited.</li> <li>Iterates through the boolean array to find missing numbers.</li> <li>Utilizes a separate method to create the boolean array, keeping the main method clean and focused.</li> <li>The boolean array is used to mark visited numbers, enabling easy identification of missing numbers.</li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/find-all-numbers-disappeared-in-an-array/#method-2-negating-the-existing-numbers","title":"Method 2 (Negating the existing numbers)","text":"<p>This solution utilizes the property of the input array to mark visited numbers without using additional space.</p> <pre><code>class Solution {\npublic List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {\n// Negate the numbers which are present\nfor (int i = 0; i &lt; nums.length; i++) {\nint index = Math.abs(nums[i]) - 1;\nif (nums[index] &gt; 0) {\nnums[index] *= -1;\n}\n}\n\nList&lt;Integer&gt; answer = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; nums.length; i++) {\nif (nums[i] &gt; 0) {\nanswer.add(i + 1);\n}\n}\n\nreturn answer;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/find-all-numbers-disappeared-in-an-array/#explanation","title":"Explanation","text":"<ul> <li>Marking Present Numbers: It negates each number's index if it's positive to mark it as visited.</li> <li>Finding Missing Numbers: It iterates through the array to find positive numbers, indicating missing numbers, and adds them to the answer list.</li> <li>Final Steps: It returns the list containing all the disappeared numbers.</li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1) [Excluding the returned array]</li> </ul>"},{"location":"leetcode-easy/first-bad-version/","title":"First Bad Version","text":""},{"location":"leetcode-easy/first-bad-version/#link-httpsleetcodecomproblemsfirst-bad-versiondescription","title":"Link - https://leetcode.com/problems/first-bad-version/description/","text":"<pre><code>/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\npublic int firstBadVersion(int n) {\nreturn findFirstBadVersion(1, n);\n}\n\n// Binary Search\nprivate int findFirstBadVersion(int start, int end) {\nif (start &gt; end) {\nreturn -1;\n}\nint mid = start + (end - start) / 2;\n\nif (isBadVersion(mid) &amp;&amp; !isBadVersion(mid - 1)) {\nreturn mid;\n}\n\nif (isBadVersion(mid)) {\nreturn findFirstBadVersion(start, mid - 1);\n}\n\nreturn findFirstBadVersion(mid + 1, end);\n}\n}\n</code></pre>"},{"location":"leetcode-easy/first-bad-version/#explanation","title":"Explanation:","text":"<ul> <li> <p>Finding the First Bad Version: The <code>firstBadVersion</code> method is the entry point of the algorithm. It calls the <code>findFirstBadVersion</code> method with the range from 1 to <code>n</code>.</p> </li> <li> <p>Binary Search Approach: The <code>findFirstBadVersion</code> method implements a binary search approach to find the first bad version. It recursively divides the range into halves and   searches in the appropriate half based on whether the midpoint is a bad version or not.</p> </li> <li> <p>Base Case: If the start index exceeds the end index, it means there are no bad versions in the current range, so it returns -1.</p> </li> <li> <p>Midpoint Calculation: It calculates the midpoint of the current range.</p> </li> <li> <p>Checking for Bad Version: If the midpoint is a bad version and the previous version is not, it means the first bad version is found, so it returns the midpoint.</p> </li> <li> <p>Recursion: If the midpoint is a bad version, it recursively searches in the left half; otherwise, it searches in the right half.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(log(n)) [due to call stack]</li> </ul>"},{"location":"leetcode-easy/implement-stack-using-queues/","title":"Implement Stack using Queues","text":""},{"location":"leetcode-easy/implement-stack-using-queues/#link-httpsleetcodecomproblemsimplement-stack-using-queues","title":"Link - https://leetcode.com/problems/implement-stack-using-queues/","text":"<pre><code>class MyStack {\n\nprivate final Queue&lt;Integer&gt; Q1;\nprivate final Queue&lt;Integer&gt; Q2;\n\npublic MyStack() {\nQ1 = new LinkedList&lt;&gt;();\nQ2 = new LinkedList&lt;&gt;();\n}\n\npublic void push(int x) {\nQ1.offer(x);\n}\n\npublic int pop() {\nif (Q1.isEmpty()) {\nthrow new IllegalArgumentException(\"Stack is empty\");\n}\nwhile (Q1.size() &gt; 1) {\nQ2.offer(Q1.poll());\n}\nint answer = Q1.poll();\nwhile (!Q2.isEmpty()) {\nQ1.offer(Q2.poll());\n}\nreturn answer;\n}\n\npublic int top() {\nif (Q1.isEmpty()) {\nthrow new IllegalArgumentException(\"Stack is empty\");\n}\nwhile (Q1.size() &gt; 1) {\nQ2.offer(Q1.poll());\n}\nint answer = Q1.poll();\nQ2.offer(answer);\nwhile (!Q2.isEmpty()) {\nQ1.offer(Q2.poll());\n}\nreturn answer;\n}\n\npublic boolean empty() {\nreturn Q1.isEmpty();\n}\n}\n</code></pre>"},{"location":"leetcode-easy/implement-stack-using-queues/#explanation","title":"Explanation","text":"<ul> <li> <p>Queue Initialization: The constructor initializes two queues, <code>Q1</code> and <code>Q2</code>, using the <code>LinkedList</code> implementation.</p> </li> <li> <p>Push Operation: The <code>push</code> method adds elements to <code>Q1</code>, effectively pushing elements onto the stack.</p> </li> <li> <p>Pop Operation: The <code>pop</code> method removes and returns the top element from the stack. It moves all elements except the last one from <code>Q1</code> to <code>Q2</code>, retrieves the last element   from <code>Q1</code>, and then moves all elements back to <code>Q1</code>.</p> </li> <li> <p>Top Operation: The <code>top</code> method returns the top element from the stack without removing it. Similar to the <code>pop</code> operation, it moves all elements except the last one   from <code>Q1</code> to <code>Q2</code>, retrieves the last element from <code>Q1</code>, moves it to <code>Q2</code> and then back to <code>Q1</code>, and finally returns the element.</p> </li> <li> <p>Empty Check: The <code>empty</code> method checks if the stack is empty by checking if <code>Q1</code> is empty.</p> </li> </ul>"},{"location":"leetcode-easy/leaf-similar-trees/","title":"Leaf Similar Trees","text":""},{"location":"leetcode-easy/leaf-similar-trees/#link-httpsleetcodecomproblemsleaf-similar-treesdescription","title":"Link - https://leetcode.com/problems/leaf-similar-trees/description/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\npublic boolean leafSimilar(TreeNode root1, TreeNode root2) {\nList&lt;Integer&gt; leafSeq1 = new ArrayList&lt;&gt;();\nleafSequence(root1, leafSeq1);\nList&lt;Integer&gt; leafSeq2 = new ArrayList&lt;&gt;();\nleafSequence(root2, leafSeq2);\n\nreturn isSimilar(leafSeq1, leafSeq2);\n}\n\nprivate void leafSequence(TreeNode root, List&lt;Integer&gt; leafSeq) {\nif (root == null) {\nreturn;\n}\nif (root.left == null &amp;&amp; root.right == null) {\nleafSeq.add(root.val);\nreturn;\n}\nleafSequence(root.left, leafSeq);\nleafSequence(root.right, leafSeq);\n}\n\nprivate boolean isSimilar(List&lt;Integer&gt; leafSeq1, List&lt;Integer&gt; leafSeq2) {\nif (leafSeq1.size() != leafSeq2.size()) {\nreturn false;\n}\nfor (int i = 0; i &lt; leafSeq1.size(); i++) {\nif (leafSeq1.get(i).intValue() != leafSeq2.get(i).intValue()) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/leaf-similar-trees/#explanation","title":"Explanation:","text":"<ul> <li> <p>Leaf Value Sequence Construction:</p> <ul> <li>The <code>leafSimilar</code> method initializes two lists (<code>leafSeq1</code> and <code>leafSeq2</code>) to store the leaf value sequences of <code>root1</code> and <code>root2</code>, respectively.</li> <li>It then invokes the <code>leafSequence</code> method for each tree to construct the leaf value sequences in a depth-first manner.</li> </ul> </li> <li> <p>Leaf Sequence Construction (<code>leafSequence</code> method):</p> <ul> <li>This method recursively traverses each tree (<code>root</code>) in a depth-first manner.</li> <li>If the current node (<code>root</code>) is a leaf node (i.e., it has no left or right child), its value is added to the corresponding <code>leafSeq</code> list.</li> <li>The traversal continues recursively for both the left and right children of the current node.</li> </ul> </li> <li> <p>Leaf Sequence Comparison (<code>isSimilar</code> method):</p> <ul> <li>After constructing the leaf value sequences for both trees (<code>root1</code> and <code>root2</code>), the <code>isSimilar</code> method is invoked to compare these sequences.</li> <li>It first checks if the sizes of <code>leafSeq1</code> and <code>leafSeq2</code> are different. If so, the trees cannot be leaf-similar, and the method returns <code>false</code>.</li> <li>If the sizes are the same, the method iterates through the leaf value sequences (<code>leafSeq1</code> and <code>leafSeq2</code>) element by element.</li> <li>If there is any mismatch between corresponding leaf values in the sequences, the method returns <code>false</code>, indicating that the trees are not leaf-similar.</li> <li>If the sequences match completely, the method returns <code>true</code>, indicating that the trees are leaf-similar.</li> </ul> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/merge-two-binary-trees/","title":"Merge two binary Trees","text":""},{"location":"leetcode-easy/merge-two-binary-trees/#link-httpsleetcodecomproblemsmerge-two-binary-trees","title":"Link - https://leetcode.com/problems/merge-two-binary-trees/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\npublic TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n// Check if both roots are null, indicating no trees to merge\nif (root1 == null &amp;&amp; root2 == null) {\nreturn null;\n}\n// If root1 is null, return root2 (the other tree)\nif (root1 == null) {\nreturn root2;\n}\n// If root2 is null, return root1 (the other tree)\nif (root2 == null) {\nreturn root1;\n}\n\n// Add the values of both roots and update the value of root1\nroot1.val = root1.val + root2.val;\n\n// Recursively merge the left subtrees and update root1's left child\nroot1.left = mergeTrees(root1.left, root2.left);\n// Recursively merge the right subtrees and update root1's right child\nroot1.right = mergeTrees(root1.right, root2.right);\n\n// Return the merged tree rooted at root1\nreturn root1;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/merge-two-binary-trees/#explanation","title":"Explanation","text":"<ul> <li> <p>Base Case: The method starts by checking if both <code>root1</code> and <code>root2</code> are null. If so, it returns null, indicating that there are no trees to merge.</p> </li> <li> <p>Null Handling: If either <code>root1</code> or <code>root2</code> is null, it returns the other root, as there's no need to merge with a null tree.</p> </li> <li> <p>Value Addition: If both <code>root1</code> and <code>root2</code> are not null, it adds the values of <code>root1</code> and <code>root2</code>, updating the value of <code>root1</code> to reflect the sum of the two roots.</p> </li> <li> <p>Recursive Merging: It then recursively merges the left subtrees of <code>root1</code> and <code>root2</code> and updates the left child of <code>root1</code>. Similarly, it merges the right subtrees and   updates the right child of <code>root1</code>.</p> </li> <li> <p>Return Merged Tree: Finally, it returns the merged tree rooted at <code>root1</code>.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n) [due to call stack]</li> </ul>"},{"location":"leetcode-easy/n-ary-tree-preorder-traversal/","title":"N-ary Tree Preorder Traversal","text":""},{"location":"leetcode-easy/n-ary-tree-preorder-traversal/#link-httpsleetcodecomproblemsn-ary-tree-preorder-traversaldescription","title":"Link - https://leetcode.com/problems/n-ary-tree-preorder-traversal/description/","text":"<pre><code>/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List&lt;Node&gt; children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List&lt;Node&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic List&lt;Integer&gt; preorder(Node root) {\nList&lt;Integer&gt; answer = new ArrayList&lt;&gt;();\npreorder(root, answer);\nreturn answer;\n}\n\nprivate void preorder(Node root, List&lt;Integer&gt; answer) {\nif (root == null) {\nreturn;\n}\nanswer.add(root.val);\nfor (Node child : root.children) {\npreorder(child, answer);\n}\n}\n}\n</code></pre>"},{"location":"leetcode-easy/n-ary-tree-preorder-traversal/#explanation","title":"Explanation","text":"<ul> <li>Preorder Traversal: The <code>preorder</code> method is the entry point of the algorithm. It initializes a list to store the preorder traversal result and calls a recursive method to   perform the traversal.</li> <li>Recursive Traversal: The <code>preorder</code> method recursively traverses the N-ary tree in preorder fashion, which means visiting the root node, then recursively traversing each   child node in preorder.</li> <li>Base Case: If the current node is null, it means the traversal has reached the end, so the method returns.</li> <li>Adding Nodes to Result: It adds the value of the current node to the result list before traversing its children.</li> <li>Iterating Through Children: It iterates through each child of the current node and recursively performs the preorder traversal on each child.</li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n) [due to call stack]</li> </ul>"},{"location":"leetcode-easy/number-of-segments-in-a-string/","title":"Number of Segments in a String","text":""},{"location":"leetcode-easy/number-of-segments-in-a-string/#link-httpsleetcodecomproblemsnumber-of-segments-in-a-stringdescription","title":"Link - https://leetcode.com/problems/number-of-segments-in-a-string/description/","text":"<pre><code>class Solution {\npublic int countSegments(String s) {\nif (s == null || s.length() == 0) {\nreturn 0;\n}\n\nint firstNonSpaceIndex = findFirstNonSpaceIndex(s);\n\nint count = 0;\nfor (int i = firstNonSpaceIndex; i &lt; s.length(); i++) {\nif (s.charAt(i) == ' ' &amp;&amp; s.charAt(i - 1) != ' ') {\ncount++;\n}\n}\n\n// Count Last word\nif (s.charAt(s.length() - 1) != ' ') {\ncount++;\n}\n\nreturn count;\n}\n\nprivate int findFirstNonSpaceIndex(String s) {\nfor (int i = 0; i &lt; s.length(); i++) {\nif (s.charAt(i) != ' ') {\nreturn i;\n}\n}\nreturn s.length();\n}\n}\n</code></pre>"},{"location":"leetcode-easy/number-of-segments-in-a-string/#explanation","title":"Explanation","text":"<ul> <li> <p>Null or Empty Check: The method first checks if the input string <code>s</code> is null or empty. If so, it returns 0, indicating that there are no segments in the string.</p> </li> <li> <p>Finding First Non-Space Index: It then finds the index of the first non-space character in the string using the <code>findFirstNonSpaceIndex</code> method.</p> </li> <li> <p>Segment Counting: It initializes a count variable to store the count of segments. It iterates through the string starting from the index of the first non-space character. For   each character, it checks if it is a space and if the previous character is not a space. If so, it increments the count to indicate a new segment.</p> </li> <li> <p>Handling Last Word: After the loop, it checks if the last word in the string is not followed by a space. If so, it increments the count to include the last word as a segment.</p> </li> <li> <p>Returning Count: Finally, it returns the count of segments in the string.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"leetcode-easy/ransom-note/","title":"Ransom Note","text":""},{"location":"leetcode-easy/ransom-note/#link-httpsleetcodecomproblemsransom-note","title":"Link - https://leetcode.com/problems/ransom-note/","text":""},{"location":"leetcode-easy/ransom-note/#method-1-using-2-maps","title":"Method 1 (Using 2 maps)","text":"<pre><code>class Solution {\npublic boolean canConstruct(String ransomNote, String magazine) {\nMap&lt;Character, Integer&gt; ransomNoteMap = constructCountMap(ransomNote);\nMap&lt;Character, Integer&gt; magazineMap = constructCountMap(magazine);\n\nfor (Map.Entry&lt;Character, Integer&gt; e : ransomNoteMap.entrySet()) {\nCharacter key = e.getKey();\nInteger value = e.getValue();\n\nif (magazineMap.get(key) == null || magazineMap.get(key) &lt; value) {\nreturn false;\n}\n}\n\nreturn true;\n}\n\nprivate Map&lt;Character, Integer&gt; constructCountMap(String s) {\nMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\nfor (char ch : s.toCharArray()) {\nmap.put(ch, map.getOrDefault(ch, 0) + 1);\n}\nreturn map;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/ransom-note/#explanation","title":"Explanation:","text":"<ul> <li> <p>Count Maps Construction: The <code>canConstruct</code> method constructs count maps for both the <code>ransomNote</code> and <code>magazine</code> strings using the <code>constructCountMap</code> method. These count   maps store the frequency of each character in the respective strings.</p> </li> <li> <p>Checking Constructibility: It iterates through the count map of <code>ransomNote</code>. For each character and its frequency in <code>ransomNote</code>, it checks if the count in the count map   of <code>magazine</code> is at least equal to the required count. If not, it means the <code>ransomNote</code> cannot be constructed using the letters from <code>magazine</code>, so it returns <code>false</code>.</p> </li> <li> <p>Returning Result: If all characters in <code>ransomNote</code> can be constructed using the letters from <code>magazine</code>, it returns <code>true</code>.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/ransom-note/#method-2-using-a-single-map","title":"Method 2 (Using a single map)","text":"<pre><code>class Solution {\npublic boolean canConstruct(String ransomNote, String magazine) {\nMap&lt;Character, Integer&gt; magazineMap = constructCountMap(magazine);\n\nfor (char ch : ransomNote.toCharArray()) {\nmagazineMap.put(ch, magazineMap.getOrDefault(ch, 0) - 1);\nif (magazineMap.get(ch) &lt; 0) {\nreturn false;\n}\n}\n\nreturn true;\n}\n\nprivate Map&lt;Character, Integer&gt; constructCountMap(String s) {\nMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\nfor (char ch : s.toCharArray()) {\nmap.put(ch, map.getOrDefault(ch, 0) + 1);\n}\nreturn map;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/ransom-note/#explanation_1","title":"Explanation","text":"<ul> <li> <p>Constructing Character Count Map: The <code>canConstruct</code> method starts by constructing a map called <code>magazineMap</code>, which stores the count of each character in the <code>magazine</code>   string. This is done using the <code>constructCountMap</code> method.</p> </li> <li> <p>Iterating Through Ransom Note: It then iterates through each character in the <code>ransomNote</code> string.</p> </li> <li> <p>Decrementing Counts: For each character in <code>ransomNote</code>, it decrements the count of that character in the <code>magazineMap</code>.</p> </li> <li> <p>Checking Availability: If at any point the count of a character becomes negative in <code>magazineMap</code>, it means that character is not available in the <code>magazine</code> string, so it   returns <code>false</code>.</p> </li> <li> <p>Returning Result: If the loop completes without encountering any negative counts, it means all characters in <code>ransomNote</code> can be constructed using the characters   from <code>magazine</code>, so it returns <code>true</code>.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/root-equals-sum-of-children/","title":"Root Equals Sum of Children","text":"<p>You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.</p>"},{"location":"leetcode-easy/root-equals-sum-of-children/#link-httpsleetcodecomproblemsroot-equals-sum-of-children","title":"Link - https://leetcode.com/problems/root-equals-sum-of-children/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif (root == null) {\nreturn true;\n}\n\nif (root.left == null &amp;&amp; root.right == null) {\nreturn true;\n}\n\nint left = root.left != null ? root.left.val : 0;\nint right = root.right != null ? root.right.val : 0;\n\nreturn root.val == left + right &amp;&amp; checkTree(root.left) &amp;&amp; checkTree(root.right);\n}\n}\n</code></pre>"},{"location":"leetcode-easy/root-equals-sum-of-children/#explanation","title":"Explanation:","text":"<ul> <li> <p>Objective: The purpose of the <code>checkTree</code> method is to validate a specific binary tree structure, which in this case consists of exactly three nodes: a root node (<code>root</code>), a   left child node (<code>root.left</code>), and a right child node (<code>root.right</code>).</p> </li> <li> <p>Base Cases:</p> <ul> <li>Empty Tree (<code>root == null</code>):<ul> <li>If the <code>root</code> node is <code>null</code>, indicating an empty tree, the method returns <code>true</code> because there is no tree structure to violate the condition.</li> </ul> </li> <li>Leaf Node (<code>root.left == null &amp;&amp; root.right == null</code>):<ul> <li>If the <code>root</code> node has no children (<code>left</code> and <code>right</code> are both <code>null</code>), it is considered a valid tree with exactly one node (the root itself), so the method returns <code>true</code>.</li> </ul> </li> </ul> </li> <li> <p>Value Calculation:</p> <ul> <li>For non-empty trees (where <code>root</code> is not <code>null</code>), the method calculates the values of the left and right children (<code>left</code> and <code>right</code>) or assumes their value as <code>0</code> if they are <code>null</code>.</li> </ul> </li> <li> <p>Validation:</p> <ul> <li>The method checks if the sum of the values of the left and right children (<code>left + right</code>) equals the value of the <code>root</code> node (<code>root.val</code>). This check ensures that the tree structure at the current node satisfies a specific condition.</li> </ul> </li> <li>Recursion:<ul> <li>The method recursively calls <code>checkTree</code> on the left subtree (<code>root.left</code>) and right subtree (<code>root.right</code>). This ensures that the entire tree structure starting from the current node (<code>root</code>) and extending to its children is validated according to the specified condition.</li> </ul> </li> <li>Return Value:<ul> <li>The method returns <code>true</code> if the tree rooted at <code>root</code> satisfies the condition (valid structure) based on the value checks and recursive validation of its subtrees. If any part of the tree structure violates the condition, the method returns <code>false</code>.</li> </ul> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"leetcode-easy/search-in-a-binary-search-tree/","title":"Search in a Binary Search Tree","text":""},{"location":"leetcode-easy/search-in-a-binary-search-tree/#link-httpsleetcodecomproblemssearch-in-a-binary-search-treedescription","title":"Link - https://leetcode.com/problems/search-in-a-binary-search-tree/description/","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\npublic TreeNode searchBST(TreeNode root, int val) {\nif (root == null) {\nreturn null;\n}\nif (root.val == val) {\nreturn root;\n}\nif (root.val &gt; val) {\nreturn searchBST(root.left, val);\n}\nreturn searchBST(root.right, val);\n}\n}\n</code></pre>"},{"location":"leetcode-easy/search-in-a-binary-search-tree/#explanation","title":"Explanation:","text":"<ul> <li> <p>Node Definition: The code begins with the definition of the binary tree node class <code>TreeNode</code>, which includes a value (<code>val</code>), and references to the left and right child   nodes (<code>left</code> and <code>right</code>).</p> </li> <li> <p>Method Explanation: The <code>searchBST</code> method searches for a node with a specific value (<code>val</code>) in the binary search tree rooted at <code>root</code>.</p> </li> <li> <p>Base Case: It starts with a base case where it checks if the current root node is null. If the root is null, it means the value was not found in the tree, and it returns   null.</p> </li> <li> <p>Value Comparison: Next, it checks if the value of the current root node (<code>root.val</code>) matches the target value (<code>val</code>). If it matches, it returns the current root node,   indicating that the value was found.</p> </li> <li> <p>Recursive Search: If the value is not found at the current root node, it decides whether to search in the left subtree or the right subtree based on a comparison between the   target value and the current root node's value:</p> <ul> <li>If the target value is less than the current node's value (<code>root.val</code>), it recursively calls <code>searchBST</code> on the left subtree (<code>root.left</code>).</li> <li>If the target value is greater than the current node's value, it recursively calls <code>searchBST</code> on the right subtree (<code>root.right</code>).</li> </ul> </li> <li> <p>Return Value: The method returns the result of the recursive call, which will eventually return either the node with the target value or null if the value is not found in the   tree.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(log(n))</li> </ul>"},{"location":"leetcode-easy/word-pattern/","title":"Word Pattern","text":""},{"location":"leetcode-easy/word-pattern/#link-httpsleetcodecomproblemsword-patterndescription","title":"Link - https://leetcode.com/problems/word-pattern/description/","text":"<pre><code>class Solution {\npublic boolean wordPattern(String pattern, String s) {\n// Check if either the pattern or the string is null\nif (pattern == null || s == null) {\nreturn false;\n}\n// Split the string into words using space as delimiter\nString[] words = s.split(\" \");\n// Check if the number of words matches the length of the pattern\nif (words.length != pattern.length()) {\nreturn false;\n}\n\n// Create two maps to store the mapping between characters and words\nMap&lt;Character, String&gt; patternToWordMap = new HashMap&lt;&gt;();\nMap&lt;String, Character&gt; wordToPatternMap = new HashMap&lt;&gt;();\n\n// Iterate through the pattern and words\nfor (int i = 0; i &lt; pattern.length(); i++) {\n// If both maps don't contain mappings for the current character and word\nif (patternToWordMap.get(pattern.charAt(i)) == null &amp;&amp; wordToPatternMap.get(words[i]) == null) {\n// Create mappings between the character and word in both maps\npatternToWordMap.put(pattern.charAt(i), words[i]);\nwordToPatternMap.put(words[i], pattern.charAt(i));\n} else {\n// If mappings exist, check if they are consistent\nif (!words[i].equals(patternToWordMap.get(pattern.charAt(i)))\n|| pattern.charAt(i) != wordToPatternMap.get(words[i])\n) {\n// If mappings are not consistent, return false\nreturn false;\n}\n}\n}\n\n// If all mappings are consistent, return true\nreturn true;\n}\n}\n</code></pre>"},{"location":"leetcode-easy/word-pattern/#explanation","title":"Explanation","text":"<ul> <li> <p>Null Check: The method starts by checking if either the pattern or the string is null. If either is null, it returns false, as there cannot be a bijection between a null   pattern or string.</p> </li> <li> <p>String Splitting: It then splits the input string <code>s</code> into words using space as the delimiter.</p> </li> <li> <p>Length Comparison: It compares the number of words obtained from splitting <code>s</code> with the length of the pattern. If they are not equal, it returns false, indicating that there   cannot be a bijection.</p> </li> <li> <p>Mapping Creation: It creates two maps: <code>patternToWordMap</code> and <code>wordToPatternMap</code> to store the mappings between characters and words.</p> </li> <li> <p>Mapping Consistency Check: It iterates through the pattern and words simultaneously. For each character-word pair, it checks if both maps contain mappings. If not, it creates   mappings between the character and word in both maps. If mappings exist, it checks if they are consistent. If mappings are not consistent, it returns false.</p> </li> <li> <p>Result Return: If all mappings are consistent, it returns true, indicating that the input string follows the given pattern.</p> </li> </ul> <p>Time and Space Complexities</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"}]}